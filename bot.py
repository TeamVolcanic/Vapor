import discord
from discord import app_commands
from discord.ext import commands
import os
import datetime
import asyncio
import json
from collections import deque
from dotenv import load_dotenv
import google.generativeai as genai
from google.generativeai.types import GenerationConfig
from google.generativeai.errors import APIError

# --- Configuration & Setup ---
load_dotenv()

# The Google Generative AI key is assumed to be in the environment variables
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")

# Initialize Gemini Client
if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)
    GEMINI_MODEL = 'gemini-2.5-flash'
    print(f"‚úÖ Gemini client configured with {GEMINI_MODEL}.")
else:
    print("‚ùå GEMINI_API_KEY not found. AI features will be unavailable.")

# Configuration for the Discord Bot
intents = discord.Intents.default()
intents.message_content = True # Required to read message content for chat
intents.members = True # Required for member checks
bot = commands.Bot(command_prefix="!", intents=intents)

# --- Bot Feature Variables (Roles removed) ---
VERIFY_ROLE_NAME = "üßëÔ∏±Member"
COMMANDS_DATA_FILE = "commands_data.json"
TICKETS_DATA_FILE = "tickets_data.json"
TICKET_CATEGORY_NAME = "Tickets"
# SUPPORT_ROLES_FILE has been removed as requested

# System instruction to enforce detailed, emoji-filled paragraph/summary,
# and to ensure no attribution like "AI Generated" is included.
AI_SYSTEM_INSTRUCTION = (
    "You are an engaging, detailed, and creative assistant. "
    "Your response must *always* be presented as a single, comprehensive paragraph or summary. "
    "Crucially, you must heavily incorporate relevant and descriptive **emojis** throughout the text "
    "to make the message visually appealing and expressive. "
    "Do not include any prefaces, attribution, or headers like 'AI generated', 'Generated by User', or 'Here is your summary'."
)

# --- Gemini API Helper Function ---

async def chat_with_ai(messages: list):
    """
    Sends a list of messages to the Gemini API with the required system instruction.
    Uses the new system instruction for consistent, emoji-filled, unattributed output.
    """
    if not GEMINI_API_KEY:
        return "Sorry, the AI feature is currently disabled due to a missing API key. ü§ñ"
    
    # Configure the generation to use the new system instruction
    config = GenerationConfig(
        system_instruction=AI_SYSTEM_INSTRUCTION
    )

    try:
        # We use a direct API call structure for clarity and control over system instructions
        response = await asyncio.to_thread(
            genai.client.models.generate_content,
            model=GEMINI_MODEL,
            contents=messages,
            config=config,
        )
        # Check if the response is safe and has text
        if response.text:
            return response.text
        elif response.candidates and response.candidates[0].safety_ratings:
             # Handle blocked content gracefully
            return "üõ°Ô∏è Your request was blocked due to safety concerns. Please try a different query. üö´"
        else:
            return "ü§ñ I received an empty or malformed response from the AI. Please try again. üõ†Ô∏è"

    except APIError as e:
        print(f"Gemini API Error: {e}")
        return f"üö® I ran into an issue communicating with the AI model: {e} üíî"
    except Exception as e:
        print(f"General AI Error: {e}")
        return f"Oops! An unexpected error occurred while processing your request: {e} üêõ"

# --- Discord Event Handlers and Commands ---

@bot.event
async def on_ready():
    """Bot initialization event."""
    print(f'‚ú® Logged in as {bot.user} (ID: {bot.user.id})')
    print('------------------------------------------------')
    # Try to sync commands on ready
    try:
        synced = await bot.tree.sync()
        print(f"ü§ñ Synced {len(synced)} command(s) globally.")
    except Exception as e:
        print(f"‚ùå Failed to sync global commands on ready: {e}")

@bot.tree.command(name="sync", description="Sync slash commands to this server (Admin only)")
@app_commands.checks.has_permissions(administrator=True)
async def sync(interaction: discord.Interaction):
    """Syncs commands for the current guild."""
    try:
        await interaction.response.defer(ephemeral=True)
        # Only sync to the current guild
        bot.tree.copy_global_to(guild=interaction.guild)
        synced = await bot.tree.sync(guild=interaction.guild)
        
        embed = discord.Embed(
            title="‚úÖ Commands Synced",
            description=f"Successfully synced {len(synced)} commands to this server!\\n\\nAll slash commands should now be visible immediately. üöÄ",
            color=discord.Color.green()
        )
        embed.set_footer(text=f"Synced by {interaction.user.display_name}")
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        await interaction.followup.send(f"‚ùå Failed to sync commands: {e} üí•", ephemeral=True)

# Placeholder command for a ticket system, explicitly omitting role logic
@bot.tree.command(name="ticket_create", description="Opens a new support ticket (no roles involved).")
async def ticket_create(interaction: discord.Interaction):
    """A placeholder for ticket creation without role management."""
    # Find the category where tickets should go
    category = discord.utils.get(interaction.guild.categories, name=TICKET_CATEGORY_NAME)
    if not category:
        await interaction.response.send_message("‚ùå Ticket category not found. Please create a category named 'Tickets' first.", ephemeral=True)
        return

    # Overwrites only for user and public, no specific support role added
    overwrites = {
        interaction.guild.default_role: discord.PermissionOverwrite(read_messages=False),
        interaction.user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
        # You might add staff/admin roles here, but no dynamic "support roles" from a file/command
    }

    # Create the channel
    ticket_channel = await interaction.guild.create_text_channel(
        name=f"ticket-{interaction.user.name.lower().replace(' ', '-')}",
        category=category,
        overwrites=overwrites
    )
    
    # Send confirmation and greeting
    await interaction.response.send_message(f"üì¨ Your ticket has been created: {ticket_channel.mention} üéâ", ephemeral=True)
    
    ticket_embed = discord.Embed(
        title="New Support Ticket",
        description=f"Welcome, {interaction.user.mention}! A member of our team will assist you shortly. Please describe your issue in detail. üìù",
        color=discord.Color.blue(),
        timestamp=datetime.datetime.now()
    )
    await ticket_channel.send(content=f"{interaction.user.mention}", embed=ticket_embed)


@bot.event
async def on_message(message: discord.Message):
    """Listens for direct mentions to engage the AI."""
    if message.author == bot.user:
        return

    # Check if the message is a direct mention or a reply to the bot
    if bot.user.mentioned_in(message) or (message.reference and message.reference.resolved and message.reference.resolved.author == bot.user):
        
        if not GEMINI_API_KEY:
            await message.channel.send("AI is currently disabled. üòî")
            return

        async with message.channel.typing():
            # 1. Build Conversation History (Clean/No Attribution)
            history = []
            
            # Fetch recent messages (e.g., last 10 messages) to build context
            # We fetch more than necessary to ensure we have enough relevant content
            raw_messages = [msg async for msg in message.channel.history(limit=10, before=message)]
            
            # Add the current user message
            raw_messages.append(message)

            # Convert Discord message objects to the Gemini API format (role/parts)
            for msg in raw_messages:
                # CRITICAL: This mapping ensures roles are correct and content is clean (no attribution text)
                if msg.author == bot.user:
                    role = "model"
                elif msg.author.bot: # Ignore other bot messages
                    continue
                else:
                    role = "user"

                # Clean the content (e.g., remove mentions if they clutter the prompt)
                content = msg.clean_content.replace(f"@{bot.user.display_name}", "").strip()

                if content:
                     history.append({"role": role, "parts": [{"text": content}]})

            # 2. Call the AI with the clean history and the formatting system instruction
            ai_response = await chat_with_ai(history)

            # 3. Send the AI response (it already follows the emoji-filled, single-paragraph format)
            await message.reply(ai_response)
        
    await bot.process_commands(message) # Important to process other commands

# --- Bot Runner ---

DISCORD_TOKEN = os.environ.get("DISCORD_TOKEN")

if not DISCORD_TOKEN:
    print("FATAL ERROR: DISCORD_TOKEN environment variable is not set. The bot cannot start.")
else:
    try:
        # Check if the token is valid before running
        bot.run(DISCORD_TOKEN)
    except discord.errors.LoginFailure:
        print("FATAL ERROR: Invalid Discord token provided. Please check your DISCORD_TOKEN.")
    except Exception as e:
        print(f"An unexpected error occurred during bot execution: {e}")
